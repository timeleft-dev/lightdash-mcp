---
phase: 02-discovery-tools
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/tools/charts.ts
  - src/tools/dashboards.ts
  - src/tools/explores.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can call lightdash_search_charts(projectUuid, query) and receive case-insensitive matches with only uuid, name, spaceName, chartType, chartKind, updatedAt, slug per result"
    - "User can call lightdash_list_dashboards(projectUuid) with optional query filter and receive only uuid, name, description, spaceUuid, updatedAt per dashboard"
    - "User can call lightdash_list_explores(projectUuid) and receive only name, label, description, tags per explore, with error status for broken explores"
    - "All 5 discovery tools are registered and the server starts cleanly"
  artifacts:
    - path: "src/tools/charts.ts"
      provides: "lightdash_search_charts tool with server-side filtering"
      exports: ["registerSearchChartsTool"]
    - path: "src/tools/dashboards.ts"
      provides: "lightdash_list_dashboards tool with optional query filter"
      exports: ["registerListDashboardsTool"]
    - path: "src/tools/explores.ts"
      provides: "lightdash_list_explores tool with error state handling"
      exports: ["registerListExploresTool"]
    - path: "src/index.ts"
      provides: "Registration wiring for all 5 discovery tools"
      contains: "registerListExploresTool"
  key_links:
    - from: "src/tools/charts.ts"
      to: "/projects/{uuid}/charts"
      via: "client.get then filter by query"
      pattern: "client\\.get.*projects/.*charts"
    - from: "src/tools/dashboards.ts"
      to: "/projects/{uuid}/dashboards"
      via: "client.get with optional filter"
      pattern: "client\\.get.*projects/.*dashboards"
    - from: "src/tools/explores.ts"
      to: "/projects/{uuid}/explores"
      via: "client.get with error state handling"
      pattern: "client\\.get.*projects/.*explores"
    - from: "src/index.ts"
      to: "all 5 tool files"
      via: "import + register calls"
      pattern: "registerListExploresTool"
---

<objective>
Implement the 3 remaining discovery tools: lightdash_search_charts (DISC-03) with server-side case-insensitive filtering, lightdash_list_dashboards (DISC-04) with optional query parameter, and lightdash_list_explores (DISC-05) with explore error state handling. Wire all into index.ts to complete Phase 2.

Purpose: Delivers the high-value chart search (compressing 413KB payloads to compact filtered results), dashboard browsing, and explore discovery. Completes all 5 discovery tools so Claude can navigate every dimension of a Lightdash project.
Output: src/tools/charts.ts, src/tools/dashboards.ts, src/tools/explores.ts, updated src/index.ts with all 5 registrations
</objective>

<execution_context>
@/Users/mikhailgasanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mikhailgasanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-discovery-tools/02-RESEARCH.md
@.planning/phases/02-discovery-tools/02-01-SUMMARY.md

# Source files -- reference for patterns and types from Plan 01
@src/tools/ping.ts
@src/types.ts
@src/index.ts
@src/client.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement search_charts, list_dashboards, and list_explores tools</name>
  <files>src/tools/charts.ts, src/tools/dashboards.ts, src/tools/explores.ts</files>
  <action>
Create 3 tool files following the established ping.ts / projects.ts / spaces.ts pattern. All use `import type` for McpServer, regular import for LightdashClient, import wrapToolHandler from errors.js, import z from "zod", and import response types from types.ts.

**1. src/tools/charts.ts -- lightdash_search_charts (DISC-03)**

This is the highest-value tool. The raw chart list can be 413KB+. Server-side filtering is critical.

- Export registerSearchChartsTool(server, client)
- Tool name: "lightdash_search_charts", title: "Search Charts"
- Description: "Search saved charts in a Lightdash project by name. Returns matching chart summaries with UUIDs and types."
- annotations: { readOnlyHint: true, destructiveHint: false }
- inputSchema: { projectUuid: z.string().describe("UUID of the Lightdash project"), query: z.string().describe("Search term to filter chart names (case-insensitive)") }
- Handler logic:
  1. Fetch all charts: client.get<LightdashChartSummary[]>(`/projects/${projectUuid}/charts`)
  2. Filter: allCharts.filter(c => c.name.toLowerCase().includes(query.toLowerCase()))
  3. If zero matches: return text "No charts found matching \"{query}\" in project {projectUuid}. Try a broader search term or use lightdash_list_spaces to browse by space."
  4. Map matches to filtered fields: { uuid, name, spaceName, chartType, chartKind, updatedAt, slug }
  5. Return JSON.stringify(filtered, null, 2)

**2. src/tools/dashboards.ts -- lightdash_list_dashboards (DISC-04)**

- Export registerListDashboardsTool(server, client)
- Tool name: "lightdash_list_dashboards", title: "List Dashboards"
- Description: "List dashboards in a Lightdash project with optional name filter. Returns dashboard summaries."
- annotations: { readOnlyHint: true, destructiveHint: false }
- inputSchema: { projectUuid: z.string().describe("UUID of the Lightdash project"), query: z.string().optional().describe("Optional search term to filter dashboard names (case-insensitive)") }
- Handler logic:
  1. Fetch all dashboards: client.get<LightdashDashboardSummary[]>(`/projects/${projectUuid}/dashboards`)
  2. If query provided, filter: dashboards.filter(d => d.name.toLowerCase().includes(query.toLowerCase()))
  3. If zero results: return appropriate empty message (include query info if filtering was applied)
  4. Map to filtered fields: { uuid, name, description, spaceUuid, updatedAt }
  5. Return JSON.stringify(filtered, null, 2)

**3. src/tools/explores.ts -- lightdash_list_explores (DISC-05)**

This tool must handle the explore union type -- explores can be in error state.

- Export registerListExploresTool(server, client)
- Tool name: "lightdash_list_explores", title: "List Explores"
- Description: "List all explores (data models) in a Lightdash project. Returns explore names, labels, descriptions, tags, and error status."
- annotations: { readOnlyHint: true, destructiveHint: false }
- inputSchema: { projectUuid: z.string().describe("UUID of the Lightdash project") }
- Handler logic:
  1. Fetch all explores: client.get<LightdashExploreSummary[]>(`/projects/${projectUuid}/explores`)
  2. Map each explore to filtered fields:
     ```typescript
     const filtered = explores.map((e) => ({
       name: e.name,
       label: e.label,
       description: e.description,
       tags: e.tags,
       ...(e.errors && e.errors.length > 0
         ? { status: "error" as const, errors: e.errors.map(err => err.message) }
         : { status: "ok" as const }),
     }));
     ```
  3. If zero explores: return "No explores found in project {projectUuid}."
  4. Return JSON.stringify(filtered, null, 2)

IMPORTANT: All 3 files must use .js extensions on imports. Use `import type` for McpServer. Use `as const` for text type literals.
  </action>
  <verify>Run `npx tsc --noEmit` -- all 3 new files must compile with zero errors. Verify each file exports its register function.</verify>
  <done>charts.ts implements server-side case-insensitive search with 7-field filtering. dashboards.ts supports optional query parameter. explores.ts handles error state with status field. All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire all 3 remaining tools into index.ts and verify complete build</name>
  <files>src/index.ts</files>
  <action>
1. Add imports to src/index.ts after the existing tool imports (from Plan 01):
```typescript
import { registerSearchChartsTool } from "./tools/charts.js";
import { registerListDashboardsTool } from "./tools/dashboards.js";
import { registerListExploresTool } from "./tools/explores.js";
```

2. Add registration calls after the existing registration calls:
```typescript
registerSearchChartsTool(server, client);
registerListDashboardsTool(server, client);
registerListExploresTool(server, client);
```

3. Run full build: `npm run build`

4. Verify all 6 tools are registered (ping + 5 discovery) by testing with JSON-RPC:
```bash
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}
{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}' | node build/index.js 2>/dev/null
```
The tools/list response must include all 6 tools: lightdash_ping, lightdash_list_projects, lightdash_list_spaces, lightdash_search_charts, lightdash_list_dashboards, lightdash_list_explores.

5. Verify build output includes all expected files: build/tools/charts.js, build/tools/dashboards.js, build/tools/explores.js.
  </action>
  <verify>Run `npm run build` -- must succeed. Run tools/list JSON-RPC test -- must show 6 tools. Verify build/tools/ contains charts.js, dashboards.js, explores.js.</verify>
  <done>All 5 discovery tools plus ping are registered in index.ts. npm run build succeeds. Server starts and lists all 6 tools via JSON-RPC tools/list. Phase 2 is complete.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. build/tools/ contains charts.js, dashboards.js, explores.js
4. Server responds to tools/list with 6 tools (ping + 5 discovery)
5. search_charts accepts projectUuid + query parameters
6. list_dashboards accepts projectUuid + optional query parameter
7. list_explores accepts projectUuid parameter
8. All tools use wrapToolHandler, readOnlyHint: true, lightdash_ prefix
</verification>

<success_criteria>
- lightdash_search_charts filters charts case-insensitively and returns only uuid, name, spaceName, chartType, chartKind, updatedAt, slug
- lightdash_list_dashboards supports optional query filter, returns only uuid, name, description, spaceUuid, updatedAt
- lightdash_list_explores returns name, label, description, tags with status indicator for errored explores
- All 6 tools (ping + 5 discovery) are registered and the server builds and starts cleanly
- Phase 2 success criteria are fully met: all 5 discovery tools callable via MCP with compact filtered responses
</success_criteria>

<output>
After completion, create `.planning/phases/02-discovery-tools/02-02-SUMMARY.md`
</output>
