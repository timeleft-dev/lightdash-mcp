---
phase: 02-discovery-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/tools/projects.ts
  - src/tools/spaces.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can call lightdash_list_projects and receive only uuid, name, and type per project"
    - "User can call lightdash_list_spaces(projectUuid) and receive only uuid, name, isPrivate, chartCount, dashboardCount, parentSpaceUuid per space"
  artifacts:
    - path: "src/types.ts"
      provides: "TypeScript interfaces for all 5 Phase 2 API response types"
      contains: "LightdashSpaceSummary"
    - path: "src/tools/projects.ts"
      provides: "lightdash_list_projects tool"
      exports: ["registerListProjectsTool"]
    - path: "src/tools/spaces.ts"
      provides: "lightdash_list_spaces tool"
      exports: ["registerListSpacesTool"]
    - path: "src/index.ts"
      provides: "Registration wiring for projects and spaces tools"
      contains: "registerListProjectsTool"
  key_links:
    - from: "src/tools/projects.ts"
      to: "/org/projects"
      via: "client.get<OrgProjectResponse[]>"
      pattern: "client\\.get.*org/projects"
    - from: "src/tools/spaces.ts"
      to: "/projects/{uuid}/spaces"
      via: "client.get<LightdashSpaceSummary[]>"
      pattern: "client\\.get.*projects/.*spaces"
    - from: "src/index.ts"
      to: "src/tools/projects.ts"
      via: "import + registerListProjectsTool(server, client)"
      pattern: "registerListProjectsTool"
---

<objective>
Add TypeScript interfaces for all 5 discovery tool response types and implement the two simplest discovery tools: lightdash_list_projects (DISC-01) and lightdash_list_spaces (DISC-02). Wire both into the server entry point.

Purpose: Establishes typed interfaces for the entire phase and delivers the first two browsable discovery capabilities. Projects are the entry point for all Lightdash navigation; spaces are the organizational layer within projects.
Output: src/types.ts with 5 new interfaces, src/tools/projects.ts, src/tools/spaces.ts, updated src/index.ts
</objective>

<execution_context>
@/Users/mikhailgasanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mikhailgasanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-discovery-tools/02-RESEARCH.md

# Source files to reference for patterns
@src/tools/ping.ts
@src/types.ts
@src/index.ts
@src/client.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add all Phase 2 response interfaces to types.ts and implement list_projects and list_spaces tools</name>
  <files>src/types.ts, src/tools/projects.ts, src/tools/spaces.ts</files>
  <action>
1. Update src/types.ts -- add ALL 5 response interfaces for Phase 2 (so Plan 02 does not need to modify this file):

```typescript
// Keep existing LightdashApiResponse<T> and LightdashProject

/** Raw project from GET /org/projects. Index signature for unknown extra fields. */
export interface OrgProjectResponse {
  projectUuid: string;
  name: string;
  type: string;
  [key: string]: unknown;
}

/** Space summary from GET /projects/{uuid}/spaces */
export interface LightdashSpaceSummary {
  uuid: string;
  name: string;
  isPrivate: boolean;
  chartCount: number;
  dashboardCount: number;
  parentSpaceUuid: string | null;
  [key: string]: unknown;
}

/** Chart entry from GET /projects/{uuid}/charts (SpaceQuery type in Lightdash) */
export interface LightdashChartSummary {
  uuid: string;
  name: string;
  description?: string;
  spaceName: string;
  spaceUuid: string;
  chartType?: string;
  chartKind?: string;
  updatedAt: string;
  slug: string;
  [key: string]: unknown;
}

/** Dashboard entry from GET /projects/{uuid}/dashboards */
export interface LightdashDashboardSummary {
  uuid: string;
  name: string;
  description?: string;
  spaceUuid: string;
  updatedAt: string;
  [key: string]: unknown;
}

/** Explore summary from GET /projects/{uuid}/explores (union type: ok or error) */
export interface LightdashExploreSummary {
  name: string;
  label: string;
  description?: string;
  tags: string[];
  errors?: Array<{ type: string; message: string }>;
  [key: string]: unknown;
}
```

2. Create src/tools/projects.ts following the exact ping.ts pattern:
- Import type McpServer, import type LightdashClient, import wrapToolHandler, import OrgProjectResponse from types
- Export registerListProjectsTool(server, client) function
- Tool name: "lightdash_list_projects", title: "List Projects"
- Description: "List all Lightdash projects in the organization. Returns project names, UUIDs, and types."
- annotations: { readOnlyHint: true, destructiveHint: false }
- No inputSchema (no parameters needed)
- Handler: client.get<OrgProjectResponse[]>("/org/projects")
- Field filtering: map to { uuid: p.projectUuid, name: p.name, type: p.type }
- Note: DISC-01 specifies warehouseType, but research confirms it may not be on the list endpoint. Use `type` field instead. If the runtime response includes warehouseType (check via [key: string]: unknown), include it. Add a comment: "warehouseType not on ProjectSummary list endpoint; type (DEFAULT/PREVIEW) provided instead"
- Return JSON.stringify(filtered, null, 2)
- Handle empty: if projects.length === 0, return "No projects found in this organization."

3. Create src/tools/spaces.ts following the exact same pattern:
- Export registerListSpacesTool(server, client) function
- Tool name: "lightdash_list_spaces", title: "List Spaces"
- Description: "List all spaces in a Lightdash project. Returns space names, UUIDs, privacy status, and content counts."
- annotations: { readOnlyHint: true, destructiveHint: false }
- inputSchema: { projectUuid: z.string().describe("UUID of the Lightdash project") }
- Import z from "zod"
- Handler: client.get<LightdashSpaceSummary[]>(`/projects/${projectUuid}/spaces`)
- Field filtering: map to { uuid, name, isPrivate, chartCount, dashboardCount, parentSpaceUuid }
- Handle empty: if spaces.length === 0, return "No spaces found in project {projectUuid}."
- Return JSON.stringify(filtered, null, 2)

IMPORTANT: Use `import type` for McpServer (only needed for type annotations). Use regular import for LightdashClient since it is used at runtime. Use .js extensions on all imports.
  </action>
  <verify>Run `npx tsc --noEmit` from the project root. All 3 files must compile with zero errors. Verify src/tools/projects.ts exports registerListProjectsTool and src/tools/spaces.ts exports registerListSpacesTool.</verify>
  <done>types.ts has 5 new interfaces (OrgProjectResponse, LightdashSpaceSummary, LightdashChartSummary, LightdashDashboardSummary, LightdashExploreSummary). projects.ts and spaces.ts each export a registerXTool function. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire list_projects and list_spaces into index.ts and verify build</name>
  <files>src/index.ts</files>
  <action>
1. Add imports to src/index.ts after the existing registerPingTool import:
```typescript
import { registerListProjectsTool } from "./tools/projects.js";
import { registerListSpacesTool } from "./tools/spaces.js";
```

2. Add registration calls after the existing registerPingTool(server, client) line:
```typescript
registerListProjectsTool(server, client);
registerListSpacesTool(server, client);
```

3. Run full build: `npm run build`

4. Verify the built server lists all 3 tools (ping + 2 new) by running:
```bash
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | node build/index.js 2>/dev/null
```
The response should include capabilities.tools. Then send tools/list to confirm 3 tools are registered.
  </action>
  <verify>Run `npm run build` -- must succeed with zero errors. Run the JSON-RPC initialize test above. The server must start and respond. Verify build/ directory contains build/tools/projects.js and build/tools/spaces.js.</verify>
  <done>index.ts imports and registers both new tools. npm run build succeeds. build/tools/projects.js and build/tools/spaces.js exist. Server starts and responds to JSON-RPC initialize.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds
3. build/tools/projects.js and build/tools/spaces.js exist
4. Server responds to JSON-RPC initialize handshake
5. src/types.ts contains all 5 Phase 2 interfaces (ready for Plan 02)
</verification>

<success_criteria>
- lightdash_list_projects tool is registered and callable (returns filtered project list with uuid, name, type)
- lightdash_list_spaces tool is registered and callable (accepts projectUuid, returns filtered space list)
- All 5 Phase 2 TypeScript interfaces exist in types.ts for Plan 02 to use
- TypeScript compiles and server starts cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-discovery-tools/02-01-SUMMARY.md`
</output>
