---
phase: 03-data-access-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/tools/charts.ts
  - src/tools/chart-results.ts
autonomous: true

must_haves:
  truths:
    - "lightdash_get_chart(chartUuid) returns chart name, description, tableName, chartType, and metricQuery (dimensions, metrics, filters, sorts, limit)"
    - "lightdash_get_chart_results(chartUuid) executes the saved chart and returns flattened rows with column names and row count"
    - "Chart results rows are flattened from nested {value:{raw,formatted}} to simple raw values"
    - "Chart results are truncated to 500 rows with a truncation message when exceeding the limit"
  artifacts:
    - path: "src/types.ts"
      provides: "Phase 3 response interfaces: SavedChartResponse, QueryResultsResponse, ExploreResponse, CompiledTableResponse, CompiledFieldResponse"
      contains: "SavedChartResponse"
    - path: "src/tools/charts.ts"
      provides: "registerGetChartTool function alongside existing registerSearchChartsTool"
      exports: ["registerGetChartTool"]
    - path: "src/tools/chart-results.ts"
      provides: "registerGetChartResultsTool function with row flattening and truncation"
      exports: ["registerGetChartResultsTool"]
  key_links:
    - from: "src/tools/charts.ts"
      to: "src/types.ts"
      via: "import type { SavedChartResponse }"
      pattern: "import type.*SavedChartResponse.*from.*types"
    - from: "src/tools/chart-results.ts"
      to: "src/types.ts"
      via: "import type { QueryResultsResponse }"
      pattern: "import type.*QueryResultsResponse.*from.*types"
    - from: "src/tools/charts.ts"
      to: "src/client.ts"
      via: "client.get<SavedChartResponse>"
      pattern: "client\\.get<SavedChartResponse>"
    - from: "src/tools/chart-results.ts"
      to: "src/client.ts"
      via: "client.post<QueryResultsResponse> with 60s timeout"
      pattern: "client\\.post<QueryResultsResponse>"
---

<objective>
Add Phase 3 TypeScript interfaces to types.ts and implement the two chart data tools: lightdash_get_chart (DATA-01) retrieves a saved chart's full configuration, and lightdash_get_chart_results (DATA-02) executes a saved chart and returns flattened result rows.

Purpose: Enables Claude to inspect what a chart queries and to execute it to see actual data -- the core "read chart" workflow.
Output: Updated types.ts with all Phase 3 interfaces, updated charts.ts with get_chart tool, new chart-results.ts with get_chart_results tool.
</objective>

<execution_context>
@/Users/mikhailgasanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mikhailgasanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-access-deployment/03-RESEARCH.md

@src/types.ts
@src/tools/charts.ts
@src/client.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Phase 3 response interfaces to types.ts</name>
  <files>src/types.ts</files>
  <action>
Add ALL Phase 3 response types below the existing Phase 2 section. Add a section comment `// -- Phase 3: Data access tool response types --` and define:

1. `SavedChartResponse` -- for GET /saved/{chartUuid}. Fields: uuid (string), projectUuid (string), name (string), description (string | undefined), tableName (string), metricQuery (object with exploreName: string, dimensions: string[], metrics: string[], filters: Record<string, unknown>, sorts: Array<{fieldId: string; descending: boolean}>, limit: number, tableCalculations: unknown[], additionalMetrics: unknown[] | undefined, customDimensions: unknown[] | undefined), chartConfig ({type?: string; [key: string]: unknown}), tableConfig ({columnOrder: string[]}), pivotConfig ({columns: string[]} | undefined), updatedAt (string), spaceName (string), spaceUuid (string), slug (string), dashboardUuid (string | null), dashboardName (string | null), plus index signature [key: string]: unknown.

2. `QueryResultsResponse` -- for POST /saved/{chartUuid}/results and POST runQuery. Fields: rows (Array<Record<string, {value: {raw: unknown; formatted: string}}>>), fields (Record<string, {fieldType: string; type: string; [key: string]: unknown}>), metricQuery (Record<string, unknown>), cacheMetadata ({cacheHit: boolean; cacheKey?: string; cacheExpiresAt?: string; cacheUpdatedTime?: string}).

3. `ExploreResponse` -- for GET /projects/{uuid}/explores/{name}. Fields: name (string), label (string), baseTable (string), tags (string[]), targetDatabase (string), type (string | undefined), groupLabel (string | undefined), tables (Record<string, CompiledTableResponse>), joinedTables (Array<{table: string; sqlOn: string; compiledSqlOn: string; type?: string; hidden?: boolean; always?: boolean; relationship?: string}>), plus index signature.

4. `CompiledTableResponse` -- Fields: name (string), label (string), description (string | undefined), dimensions (Record<string, CompiledFieldResponse>), metrics (Record<string, CompiledFieldResponse>), plus index signature.

5. `CompiledFieldResponse` -- Fields: name (string), label (string), table (string), type (string), description (string | undefined), hidden (boolean | undefined), fieldType (string), plus index signature.

These types are used by Plans 01 and 02 tools. Adding them all now avoids types.ts file conflicts between plans.
  </action>
  <verify>Run `npx tsc --noEmit` from project root -- should compile with no errors (existing code still valid, new types are additive).</verify>
  <done>types.ts contains SavedChartResponse, QueryResultsResponse, ExploreResponse, CompiledTableResponse, and CompiledFieldResponse interfaces. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Implement lightdash_get_chart and lightdash_get_chart_results tools</name>
  <files>src/tools/charts.ts, src/tools/chart-results.ts</files>
  <action>
**charts.ts -- Add registerGetChartTool alongside existing registerSearchChartsTool:**

Add a new exported function `registerGetChartTool(server: McpServer, client: LightdashClient): void` following the exact same pattern as registerSearchChartsTool. Specifics:

- Tool name: `"lightdash_get_chart"`
- Title: `"Get Chart"`
- Description: `"Get the full configuration of a saved chart including its query definition, chart type, and table name. Use the chartUuid from lightdash_search_charts."`
- Annotations: `{ readOnlyHint: true, destructiveHint: false }`
- inputSchema: `{ chartUuid: z.string().describe("UUID of the saved chart (from lightdash_search_charts)") }`
- Handler: calls `client.get<SavedChartResponse>(\`/saved/${chartUuid}\`)`, then filters the response to return only: uuid, name, description, tableName, spaceName, chartType (from chartConfig.type), and metricQuery (only dimensions, metrics, filters, sorts, limit fields). Return as JSON.stringify(filtered, null, 2).
- Import `SavedChartResponse` from `../types.js` (add to existing type import line).
- Use `import type` for McpServer (already done in file).
- Wrap handler with `wrapToolHandler`.

**chart-results.ts -- New file, implement registerGetChartResultsTool:**

Create new file `src/tools/chart-results.ts` following the exact pattern of other tool files. Specifics:

- File comment: `Discovery tool: lightdash_get_chart_results (DATA-02)` with description of what it does.
- Imports: `import type { McpServer }` from sdk, `{ z }` from zod, `{ LightdashClient }` from client.js, `{ wrapToolHandler }` from errors.js, `import type { QueryResultsResponse }` from types.js.
- Export function: `registerGetChartResultsTool(server: McpServer, client: LightdashClient): void`
- Tool name: `"lightdash_get_chart_results"`
- Title: `"Get Chart Results"`
- Description: `"Execute a saved chart and return the query results as data rows. Returns column names and flattened row values."`
- Annotations: `{ readOnlyHint: true, destructiveHint: false }`
- inputSchema: `{ chartUuid: z.string().describe("UUID of the saved chart (from lightdash_search_charts)") }`
- Handler: calls `client.post<QueryResultsResponse>(\`/saved/${chartUuid}/results\`, {}, 60_000)` (60s timeout for query execution). Then:
  1. Set `MAX_ROWS = 500`
  2. Get `allRows = results.rows`
  3. Slice to `rows = allRows.slice(0, MAX_ROWS)`
  4. Flatten rows: map each row to extract raw values with defensive access: `val?.value?.raw ?? val?.value ?? val` for each entry
  5. Build response object: `{ columns: Object.keys(results.fields), rows: simpleRows, rowCount: allRows.length }`
  6. If `allRows.length > MAX_ROWS`, add `truncated: true` and `message: \`Showing ${MAX_ROWS} of ${allRows.length} rows\``
  7. Return as `JSON.stringify(response, null, 2)`
- Wrap handler with `wrapToolHandler`.

IMPORTANT: Use `.js` extensions on all local imports. Use `import type` for McpServer. Use regular import for LightdashClient.
  </action>
  <verify>Run `npx tsc --noEmit` -- should compile with no errors. Verify both new exports exist: `grep -n "registerGetChartTool\|registerGetChartResultsTool" src/tools/charts.ts src/tools/chart-results.ts`</verify>
  <done>charts.ts exports both registerSearchChartsTool (existing) and registerGetChartTool (new). chart-results.ts exports registerGetChartResultsTool with row flattening and 500-row truncation. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. types.ts contains all 5 Phase 3 interfaces (SavedChartResponse, QueryResultsResponse, ExploreResponse, CompiledTableResponse, CompiledFieldResponse)
3. charts.ts exports registerGetChartTool (new) alongside registerSearchChartsTool (existing)
4. chart-results.ts is a new file exporting registerGetChartResultsTool
5. get_chart_results uses 60s timeout and 500-row truncation with flattened row values
</verification>

<success_criteria>
- All Phase 3 type interfaces present in types.ts
- lightdash_get_chart tool returns filtered chart config (uuid, name, description, tableName, spaceName, chartType, metricQuery subset)
- lightdash_get_chart_results tool executes chart with 60s timeout, flattens row values from nested {value:{raw,formatted}} to raw, truncates at 500 rows with metadata
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-access-deployment/03-01-SUMMARY.md`
</output>
