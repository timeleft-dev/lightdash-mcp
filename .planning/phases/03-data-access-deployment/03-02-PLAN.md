---
phase: 03-data-access-deployment
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/tools/explores.ts
  - src/tools/query.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "lightdash_get_explore(projectUuid, exploreName) returns explore schema with tables, visible dimensions, visible metrics, and joins"
    - "Explore schema filters out hidden dimensions/metrics and omits SQL/compiledSql fields"
    - "lightdash_run_raw_query executes ad-hoc queries with dimensions, metrics, optional filters/sorts/limit and returns flattened rows"
    - "Run raw query uses native Lightdash filter format passed through as-is (z.any() for filters)"
    - "Run raw query defaults tableCalculations to [] and uses 60s timeout"
    - "All 4 new tools are registered in index.ts and the server starts with 10 total tools"
  artifacts:
    - path: "src/tools/explores.ts"
      provides: "registerGetExploreTool function alongside existing registerListExploresTool"
      exports: ["registerGetExploreTool"]
    - path: "src/tools/query.ts"
      provides: "registerRunRawQueryTool function with native filter passthrough and row flattening"
      exports: ["registerRunRawQueryTool"]
    - path: "src/index.ts"
      provides: "All 10 tool registrations (6 existing + 4 new)"
      contains: "registerGetChartTool"
  key_links:
    - from: "src/tools/explores.ts"
      to: "src/types.ts"
      via: "import type { ExploreResponse, CompiledTableResponse, CompiledFieldResponse }"
      pattern: "import type.*ExploreResponse.*from.*types"
    - from: "src/tools/query.ts"
      to: "src/types.ts"
      via: "import type { QueryResultsResponse }"
      pattern: "import type.*QueryResultsResponse.*from.*types"
    - from: "src/tools/explores.ts"
      to: "src/client.ts"
      via: "client.get<ExploreResponse> with encodeURIComponent"
      pattern: "client\\.get<ExploreResponse>"
    - from: "src/tools/query.ts"
      to: "src/client.ts"
      via: "client.post<QueryResultsResponse> with 60s timeout"
      pattern: "client\\.post<QueryResultsResponse>"
    - from: "src/index.ts"
      to: "src/tools/charts.ts"
      via: "import { registerGetChartTool }"
      pattern: "registerGetChartTool"
    - from: "src/index.ts"
      to: "src/tools/chart-results.ts"
      via: "import { registerGetChartResultsTool }"
      pattern: "registerGetChartResultsTool"
    - from: "src/index.ts"
      to: "src/tools/explores.ts"
      via: "import { registerGetExploreTool }"
      pattern: "registerGetExploreTool"
    - from: "src/index.ts"
      to: "src/tools/query.ts"
      via: "import { registerRunRawQueryTool }"
      pattern: "registerRunRawQueryTool"
---

<objective>
Implement the explore schema tool (DATA-03), the ad-hoc query tool (DATA-04), and register all 4 new Phase 3 tools in the server entry point. After this plan, the MCP server has all 10 tools and compiles cleanly.

Purpose: Enables Claude to inspect explore schemas to discover available dimensions/metrics, and to run ad-hoc queries against Lightdash -- the full data access workflow.
Output: Updated explores.ts with get_explore tool, new query.ts with run_raw_query tool, updated index.ts with all 10 tool registrations.
</objective>

<execution_context>
@/Users/mikhailgasanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mikhailgasanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-access-deployment/03-RESEARCH.md
@.planning/phases/03-data-access-deployment/03-01-SUMMARY.md

@src/types.ts
@src/tools/explores.ts
@src/tools/charts.ts
@src/index.ts
@src/client.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement lightdash_get_explore tool in explores.ts</name>
  <files>src/tools/explores.ts</files>
  <action>
Add a new exported function `registerGetExploreTool(server: McpServer, client: LightdashClient): void` alongside the existing `registerListExploresTool`. Specifics:

- Add imports for `ExploreResponse`, `CompiledTableResponse`, `CompiledFieldResponse` from `../types.js` (add to existing type import line).
- Tool name: `"lightdash_get_explore"`
- Title: `"Get Explore"`
- Description: `"Get the full schema of a Lightdash explore including all tables, dimensions, metrics, and joins. Use the explore name from lightdash_list_explores. Returns only visible fields with name, label, type, and description (SQL internals omitted)."`
- Annotations: `{ readOnlyHint: true, destructiveHint: false }`
- inputSchema: `{ projectUuid: z.string().describe("UUID of the Lightdash project"), exploreName: z.string().describe("Name of the explore (from lightdash_list_explores)") }`
- Handler: calls `client.get<ExploreResponse>(\`/projects/${projectUuid}/explores/${encodeURIComponent(exploreName)}\`)` -- MUST use encodeURIComponent on exploreName to handle special characters.
- Filter the response:
  1. Top level: name, label, baseTable, tags
  2. Tables: for each table in `Object.values(explore.tables)`, create a filtered table with: name, label, description, dimensions (array), metrics (array)
  3. Dimensions: `Object.values(table.dimensions).filter(d => !d.hidden).map(d => ({ name: d.name, label: d.label, type: d.type, description: d.description }))` -- filter out hidden, omit SQL fields
  4. Metrics: same pattern as dimensions -- `Object.values(table.metrics).filter(m => !m.hidden).map(m => ({ name: m.name, label: m.label, type: m.type, description: m.description }))`
  5. Joins: `explore.joinedTables.filter(j => !j.hidden).map(j => ({ table: j.table, type: j.type, relationship: j.relationship }))` -- filter hidden, omit sqlOn/compiledSqlOn
- Return as `JSON.stringify(filtered, null, 2)`.
- Wrap handler with `wrapToolHandler`.
  </action>
  <verify>Run `npx tsc --noEmit` -- should compile cleanly. Verify export: `grep -n "registerGetExploreTool" src/tools/explores.ts`</verify>
  <done>explores.ts exports both registerListExploresTool (existing) and registerGetExploreTool (new). Hidden fields filtered out, SQL internals omitted, encodeURIComponent used on explore name.</done>
</task>

<task type="auto">
  <name>Task 2: Implement lightdash_run_raw_query tool and register all Phase 3 tools</name>
  <files>src/tools/query.ts, src/index.ts</files>
  <action>
**query.ts -- New file, implement registerRunRawQueryTool:**

Create new file `src/tools/query.ts`. Specifics:

- File comment: `Data access tool: lightdash_run_raw_query (DATA-04)` with description of ad-hoc query execution.
- Imports: `import type { McpServer }` from sdk, `{ z }` from zod, `{ LightdashClient }` from client.js, `{ wrapToolHandler }` from errors.js, `import type { QueryResultsResponse }` from types.js.
- Export function: `registerRunRawQueryTool(server: McpServer, client: LightdashClient): void`
- Tool name: `"lightdash_run_raw_query"`
- Title: `"Run Raw Query"`
- Description: `"Execute an ad-hoc metric query against a Lightdash explore. Specify dimensions, metrics, and optionally filters (native Lightdash format), sorts, and row limit. Use lightdash_get_explore first to discover available fields."`
- Annotations: `{ readOnlyHint: true, destructiveHint: false }`
- inputSchema:
  ```
  projectUuid: z.string().describe("UUID of the Lightdash project")
  exploreName: z.string().describe("Name of the explore (from lightdash_list_explores)")
  dimensions: z.array(z.string()).describe("Array of dimension field IDs (e.g., ['orders_created_date', 'customers_name'])")
  metrics: z.array(z.string()).describe("Array of metric field IDs (e.g., ['orders_total_revenue', 'orders_count'])")
  filters: z.any().optional().describe("Native Lightdash filters object. Structure: { dimensions?: { id, and|or: [{ id, target: { fieldId }, operator, values?, settings? }] }, metrics?: { ... } }. Operators: equals, notEquals, contains, startsWith, greaterThan, lessThan, inThePast, inBetween, isNull, notNull, etc.")
  sorts: z.array(z.object({ fieldId: z.string(), descending: z.boolean() })).optional().describe("Sort order. Each item has fieldId and descending (true for DESC).")
  limit: z.number().optional().default(500).describe("Max rows to return (default 500, max 5000)")
  ```
- Handler typed args: `{ projectUuid: string; exploreName: string; dimensions: string[]; metrics: string[]; filters?: unknown; sorts?: Array<{fieldId: string; descending: boolean}>; limit: number }`
- Handler logic:
  1. Clamp limit: `const clampedLimit = Math.min(limit, 5000)`
  2. Build request body: `{ exploreName, dimensions, metrics, filters: filters ?? {}, sorts: sorts ?? [], limit: clampedLimit, tableCalculations: [] }` -- MUST default tableCalculations to [] (required by API).
  3. Call `client.post<QueryResultsResponse>(\`/projects/${projectUuid}/explores/${encodeURIComponent(exploreName)}/runQuery\`, body, 60_000)` -- 60s timeout, encodeURIComponent on exploreName.
  4. Apply same row flattening as chart-results.ts: MAX_ROWS = 500, slice, flatten `val?.value?.raw ?? val?.value ?? val`, build response with columns/rows/rowCount/truncated/message.
  5. Return as `JSON.stringify(response, null, 2)`.
- Wrap handler with `wrapToolHandler`.
- Use `.js` extensions on all local imports.

**index.ts -- Register all 4 new tools:**

Add 4 new imports after existing tool imports:
```
import { registerGetChartTool } from "./tools/charts.js";
import { registerGetChartResultsTool } from "./tools/chart-results.js";
import { registerGetExploreTool } from "./tools/explores.js";
import { registerRunRawQueryTool } from "./tools/query.js";
```

Note: registerSearchChartsTool and registerGetChartTool are both exported from charts.ts. Combine them in a single import line: `import { registerSearchChartsTool, registerGetChartTool } from "./tools/charts.js";` (replace the existing single import).

Similarly for explores.ts: `import { registerListExploresTool, registerGetExploreTool } from "./tools/explores.js";` (replace the existing single import).

Add 4 new registration calls after existing ones:
```
registerGetChartTool(server, client);
registerGetChartResultsTool(server, client);
registerGetExploreTool(server, client);
registerRunRawQueryTool(server, client);
```

The server should now register 10 tools total (6 existing + 4 new).
  </action>
  <verify>Run `npx tsc --noEmit` -- should compile cleanly. Run `npm run build` to verify build/ output is created. Count tool registrations: `grep -c "register.*Tool(server" src/index.ts` should output 10.</verify>
  <done>query.ts exports registerRunRawQueryTool with native filter passthrough, 60s timeout, 500-row truncation, and [] tableCalculations default. index.ts imports and registers all 10 tools. TypeScript compiles and builds cleanly.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` succeeds and creates build/ directory
3. explores.ts exports registerGetExploreTool with schema filtering (hidden fields excluded, SQL omitted)
4. query.ts exports registerRunRawQueryTool with native Lightdash filter passthrough (z.any())
5. index.ts has 10 tool registrations (6 existing + 4 new)
6. Both new tools use 60s timeout and encodeURIComponent on explore names
7. run_raw_query defaults tableCalculations to [] in request body
</verification>

<success_criteria>
- lightdash_get_explore returns filtered schema: tables with visible dimensions/metrics (name, label, type, description only) and joins (table, type, relationship only)
- lightdash_run_raw_query accepts native Lightdash filters via z.any(), defaults tableCalculations to [], clamps limit to 5000, uses 60s timeout
- All 10 tools registered in index.ts
- `npm run build` produces clean build/ output
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-access-deployment/03-02-SUMMARY.md`
</output>
