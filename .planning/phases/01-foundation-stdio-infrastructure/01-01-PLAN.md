---
phase: 01-foundation-stdio-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - src/logger.ts
  - src/errors.ts
  - src/types.ts
autonomous: true

must_haves:
  truths:
    - "npm install succeeds with exactly 4 packages (2 runtime, 2 dev)"
    - "tsc --noEmit passes with zero errors on all source files"
    - "console.log is overridden to write to stderr before any module imports"
    - "LightdashApiError extracts safe message from JSON error body without leaking URLs or keys"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with ESM config and all dependencies"
      contains: "type.*module"
    - path: "tsconfig.json"
      provides: "TypeScript config targeting ES2022 with Node16 module resolution"
      contains: "Node16"
    - path: "src/logger.ts"
      provides: "Stderr-only logging and stdout guard setup"
      exports: ["log", "setupStdoutGuard"]
    - path: "src/errors.ts"
      provides: "LightdashApiError class, error sanitization, wrapToolHandler"
      exports: ["LightdashApiError", "formatErrorForLLM", "sanitizeErrorMessage", "wrapToolHandler"]
    - path: "src/types.ts"
      provides: "Shared TypeScript interfaces for Lightdash API responses"
  key_links:
    - from: "src/errors.ts"
      to: "src/logger.ts"
      via: "imports log function for stderr error logging"
      pattern: "import.*logger"
---

<objective>
Scaffold the project and create foundational modules: stdout guards, stderr logger, error types with sanitization, and the wrapToolHandler utility.

Purpose: Every subsequent module (client, server, tools) imports from these files. They must exist first with correct types and exports. The stdout guard is the most critical piece -- it prevents the #1 MCP failure mode (stdout pollution).

Output: A buildable TypeScript project with package.json, tsconfig.json, and three source modules (logger.ts, errors.ts, types.ts).
</objective>

<execution_context>
@/Users/mikhailgasanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mikhailgasanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-stdio-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize project with package.json, tsconfig.json, and install dependencies</name>
  <files>package.json, tsconfig.json</files>
  <action>
Create package.json with these exact settings:
- "name": "lightdash-mcp-server"
- "version": "1.0.0"
- "type": "module" (ESM required -- SDK is ESM-only)
- "bin": { "lightdash-mcp": "./build/index.js" }
- "scripts": { "build": "tsc", "start": "node build/index.js", "inspect": "npx @modelcontextprotocol/inspector node build/index.js" }
- "files": ["build"]
- dependencies: "@modelcontextprotocol/sdk": "^1.26.0", "zod": "^3.25.0"
- devDependencies: "@types/node": "^22.0.0", "typescript": "^5.9.0"

Create tsconfig.json with these exact settings:
- "target": "ES2022"
- "module": "Node16"
- "moduleResolution": "Node16"
- "outDir": "./build"
- "rootDir": "./src"
- "strict": true
- "esModuleInterop": true
- "skipLibCheck": true
- "forceConsistentCasingInFileNames": true
- "include": ["src/**/*"]
- "exclude": ["node_modules"]

Create the src/ directory.

Run `npm install` to install all dependencies.

IMPORTANT: Use Node16 module/moduleResolution (not NodeNext) per research. Use ES2022 target for stable built-in fetch and AbortSignal.timeout.
  </action>
  <verify>
Run: `cd "/Users/mikhailgasanov/Documents/Lightdash MCP" && npm ls --depth=0` -- should show @modelcontextprotocol/sdk, zod, @types/node, typescript with no missing/extraneous warnings.
Run: `node -e "import('./package.json', { assert: { type: 'json' } }).then(m => console.log(m.default.type))"` from project root -- should print "module".
  </verify>
  <done>package.json and tsconfig.json exist with correct settings, node_modules installed with all 4 packages, no errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create logger.ts, errors.ts, and types.ts foundation modules</name>
  <files>src/logger.ts, src/errors.ts, src/types.ts</files>
  <action>
**src/logger.ts** -- Stderr-only logging and stdout guard:

1. Export `setupStdoutGuard()` function that:
   - Overrides `console.log` to redirect to `console.error` with a "[redirected]" prefix
   - This MUST be called as the very first thing in index.ts before any imports
2. Export `log` object with methods: `info()`, `warn()`, `error()`, `debug()` -- all writing to stderr via `console.error`
3. All methods prefix output with a tag like `[lightdash-mcp]` for easy filtering

**src/errors.ts** -- Error types and sanitization (INFRA-07, INFRA-09):

1. Export `LightdashApiError` class extending Error:
   - Constructor takes `statusCode: number` and `rawBody: string`
   - Parses rawBody as JSON to extract `error.message` or `message` field for `safeMessage`
   - Falls back to `HTTP {statusCode}` if parsing fails
   - Properties: `statusCode` (number), `safeMessage` (string)

2. Export `sanitizeErrorMessage(msg: string): string` that:
   - Replaces `ApiKey ...` tokens with `ApiKey [REDACTED]`
   - Replaces `http://` and `https://` URLs with `[URL REDACTED]`
   - Strips stack trace frames (lines matching `at ... (...)`)

3. Export `formatErrorForLLM(error: unknown): string` that:
   - If `LightdashApiError`: returns "Lightdash API error ({statusCode}): {safeMessage}"
   - If `Error` with name "TimeoutError": returns "Request timed out. The Lightdash instance may be slow or unreachable. Try again or check the server status."
   - If other Error: returns sanitized error.message
   - Otherwise: returns generic "An unexpected error occurred. Check server logs for details."

4. Export `wrapToolHandler` generic function:
   - Import `CallToolResult` from `@modelcontextprotocol/sdk/types.js`
   - Takes a handler function `(args: T) => Promise<CallToolResult>`
   - Returns a wrapper that calls the handler in try/catch
   - On catch: returns `{ isError: true, content: [{ type: "text", text: formatErrorForLLM(error) }] }`
   - Log full error details to stderr via logger for debugging

**src/types.ts** -- Shared TypeScript interfaces:

1. Export `LightdashApiResponse<T>` interface: `{ status: string; results: T }`
2. Export `LightdashProject` interface: `{ projectUuid: string; name: string; warehouseType: string }`
3. Add a comment noting this file will grow as tools are added in Phase 2+

IMPORTANT: All imports between these files MUST use `.js` extension (ESM requirement). Example: `import { log } from "./logger.js"`.
  </action>
  <verify>
Run: `cd "/Users/mikhailgasanov/Documents/Lightdash MCP" && npx tsc --noEmit` -- should produce zero errors.
Verify exports: `npx tsc && node -e "import('./build/errors.js').then(m => console.log(Object.keys(m)))"` -- should list LightdashApiError, formatErrorForLLM, sanitizeErrorMessage, wrapToolHandler.
  </verify>
  <done>All three source files compile with zero TypeScript errors. logger.ts exports setupStdoutGuard and log. errors.ts exports LightdashApiError, formatErrorForLLM, sanitizeErrorMessage, wrapToolHandler. types.ts exports LightdashApiResponse and LightdashProject interfaces. All imports use .js extensions.</done>
</task>

</tasks>

<verification>
1. `npm ls --depth=0` shows all 4 packages installed
2. `npx tsc --noEmit` produces zero errors
3. `npx tsc && node -e "import('./build/logger.js').then(m => console.log(Object.keys(m)))"` shows setupStdoutGuard, log
4. `npx tsc && node -e "import('./build/errors.js').then(m => console.log(Object.keys(m)))"` shows LightdashApiError, formatErrorForLLM, sanitizeErrorMessage, wrapToolHandler
</verification>

<success_criteria>
- Project scaffolding complete with ESM config
- All foundation modules compile and export correctly
- Stdout guard function exists and redirects console.log to stderr
- Error sanitization strips API keys, URLs, and stack traces
- wrapToolHandler catches errors and returns isError: true format
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-stdio-infrastructure/01-01-SUMMARY.md`
</output>
