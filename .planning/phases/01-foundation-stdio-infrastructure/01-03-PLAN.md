---
phase: 01-foundation-stdio-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/index.ts
  - src/tools/ping.ts
autonomous: true
user_setup:
  - service: lightdash
    why: "MCP server connects to Lightdash API for smoke test verification"
    env_vars:
      - name: LIGHTDASH_API_KEY
        source: "Lightdash instance -> Settings -> Personal Access Tokens -> Create new token"
      - name: LIGHTDASH_API_URL
        source: "Your Lightdash instance base URL (e.g., https://lightdash.yourcompany.com)"

must_haves:
  truths:
    - "Server starts via stdio transport and produces zero non-JSON-RPC output on stdout"
    - "Server fails fast with clear stderr message if LIGHTDASH_API_KEY or LIGHTDASH_API_URL is missing"
    - "lightdash_ping tool is callable and returns server status with lightdash_ prefix and readOnlyHint annotation"
    - "lightdash_ping demonstrates field filtering by returning only selected fields from API response"
    - "Tool errors return isError: true with actionable message, not thrown exceptions"
    - "TypeScript compiles cleanly to build/ directory via npm run build"
  artifacts:
    - path: "src/index.ts"
      provides: "Server entry point with stdout guard, env validation, server bootstrap"
      min_lines: 30
    - path: "src/tools/ping.ts"
      provides: "Smoke test tool proving full stack works end-to-end"
      exports: ["registerPingTool"]
    - path: "build/index.js"
      provides: "Compiled JavaScript entry point"
  key_links:
    - from: "src/index.ts"
      to: "src/logger.ts"
      via: "calls setupStdoutGuard() as FIRST action before other imports"
      pattern: "setupStdoutGuard"
    - from: "src/index.ts"
      to: "src/client.ts"
      via: "creates LightdashClient instance with validated env vars"
      pattern: "new LightdashClient"
    - from: "src/index.ts"
      to: "@modelcontextprotocol/sdk"
      via: "creates McpServer and connects StdioServerTransport"
      pattern: "McpServer|StdioServerTransport"
    - from: "src/tools/ping.ts"
      to: "src/errors.ts"
      via: "uses wrapToolHandler to catch errors and return isError format"
      pattern: "wrapToolHandler"
    - from: "src/tools/ping.ts"
      to: "src/client.ts"
      via: "calls client.get() to hit Lightdash API"
      pattern: "client\\.get"
---

<objective>
Wire everything together: create the server entry point (index.ts) with stdout guards, env validation, and transport setup, plus a lightdash_ping smoke-test tool that validates the full stack end-to-end. Then verify TypeScript compilation.

Purpose: This is the integration plan. Plan 01 created the foundation modules, Plan 02 created the API client. This plan connects them into a working MCP server with a real tool that proves auth, envelope unwrapping, field filtering, error handling, and stdio transport all work correctly.

Output: A fully functional MCP server that starts, connects via stdio, and exposes a lightdash_ping tool. TypeScript compiles to build/.
</objective>

<execution_context>
@/Users/mikhailgasanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mikhailgasanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-stdio-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-stdio-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-stdio-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server entry point (index.ts) with stdout guard, env validation, and transport bootstrap</name>
  <files>src/index.ts</files>
  <action>
Create `src/index.ts` as the server entry point. The file structure MUST follow this exact order:

1. **Shebang line:** `#!/usr/bin/env node`

2. **Stdout guard -- FIRST, before ANY other imports (INFRA-01):**
   Call `setupStdoutGuard()` from logger.ts. BUT there is a subtlety: we need to redirect console.log BEFORE importing the SDK (which might use console.log during init). The cleanest approach:
   - Inline the console.log override directly at the top of index.ts: `console.log = (...args: unknown[]) => console.error("[redirected]", ...args);`
   - Then import everything else below

3. **Imports:** McpServer from SDK, StdioServerTransport from SDK, LightdashClient, log from logger, registerPingTool from tools/ping.js

4. **Environment validation (INFRA-02):**
   - Read `process.env.LIGHTDASH_API_KEY` and `process.env.LIGHTDASH_API_URL`
   - If either is missing, log a FATAL error to stderr with specific guidance:
     - "LIGHTDASH_API_KEY is not set" / "LIGHTDASH_API_URL is not set"
     - "Set these in Claude Desktop config under mcpServers.lightdash.env"
   - Call `process.exit(1)` immediately

5. **Create McpServer:**
   ```
   const server = new McpServer({ name: "lightdash", version: "1.0.0" });
   ```

6. **Create LightdashClient:**
   ```
   const client = new LightdashClient({ baseUrl: apiUrl, apiKey });
   ```

7. **Register tools:**
   ```
   registerPingTool(server, client);
   ```

8. **Main function:** Create StdioServerTransport, call `server.connect(transport)`, log startup message to stderr.

9. **Top-level error handler:** `main().catch(error => { console.error("Fatal:", error); process.exit(1); });`

IMPORTANT:
- The console.log override MUST be the FIRST executable line after the shebang
- All imports come AFTER the override
- NEVER use console.log anywhere else in the codebase -- use the `log` utility from logger.ts
- The main function is async and uses await
  </action>
  <verify>
Run: `cd "/Users/mikhailgasanov/Documents/Lightdash MCP" && npx tsc --noEmit` -- zero errors.
Run: `npx tsc` -- compiles to build/ with zero errors.
Run: `echo '{}' | LIGHTDASH_API_KEY=test LIGHTDASH_API_URL=https://example.com timeout 3 node build/index.js 2>/dev/null | head -1` -- should either output valid JSON-RPC or nothing (not crash with import errors).
Run: `timeout 2 node build/index.js 2>&1 >/dev/null || true` -- stderr should contain "FATAL" message about missing env vars when neither is set.
  </verify>
  <done>index.ts compiles, stdout guard is first executable line, env validation exits with clear stderr on missing vars, server creates and connects transport without errors when env vars are provided.</done>
</task>

<task type="auto">
  <name>Task 2: Create lightdash_ping smoke-test tool with field filtering and verify full compilation</name>
  <files>src/tools/ping.ts</files>
  <action>
Create `src/tools/ping.ts` -- a smoke-test tool that validates the entire stack.

Export `registerPingTool(server: McpServer, client: LightdashClient)` function that registers a `lightdash_ping` tool:

1. **Tool registration using server.registerTool():**
   - Name: `"lightdash_ping"` (INFRA-10: lightdash_ prefix)
   - Config object with:
     - `title`: "Ping Lightdash"
     - `description`: "Test connectivity to the Lightdash instance. Returns server status and basic org info."
     - `annotations`: `{ readOnlyHint: true, destructiveHint: false }` (INFRA-11)
     - `inputSchema`: empty object `{}` (no parameters)

2. **Handler wrapped with wrapToolHandler (INFRA-07):**
   The handler should:
   - Call `client.get("/org")` to fetch org info (this tests auth, URL normalization, envelope unwrapping, and timeouts all at once)
   - Apply server-side field filtering (INFRA-06): from the org response, return ONLY `{ organizationName, organizationUuid, needsProject }` -- discard all other fields
   - Return the filtered result as `{ content: [{ type: "text", text: JSON.stringify(filtered, null, 2) }] }`

3. **Import types:** McpServer from SDK, LightdashClient from client.js, wrapToolHandler from errors.js, z from zod (for inputSchema even if empty)

The tool validates ALL infrastructure requirements:
- INFRA-01: If stdout is polluted, MCP Inspector will fail
- INFRA-03/04/05: Client handles URL, auth, and unwrapping
- INFRA-06: Field filtering reduces org response to 3 fields
- INFRA-07/09: wrapToolHandler catches errors, sanitizes messages
- INFRA-08: Client timeout applies
- INFRA-10: lightdash_ prefix
- INFRA-11: readOnlyHint annotation

After creating the tool, run full compilation:
- `npm run build` must succeed with zero errors
- Verify build/ directory contains index.js, client.js, errors.js, logger.js, types.js, tools/ping.js

IMPORTANT: Import McpServer type using: `import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";` (use `import type` to avoid runtime import issues if the class is only needed for typing).

Actually, since we call `server.registerTool()` on the instance, we need the runtime type. Use: `import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";` if needed for the parameter type annotation -- OR simply use a type-only import and let TypeScript infer. The simpler approach: use `import type` for the type and pass `server: InstanceType<typeof McpServer>` -- but the cleanest is just `import { McpServer }` since it is already imported in index.ts and this module is always loaded after. Use whichever approach compiles cleanly.
  </action>
  <verify>
Run: `cd "/Users/mikhailgasanov/Documents/Lightdash MCP" && npm run build` -- must exit 0 with no errors.
Run: `ls build/tools/ping.js` -- file must exist.
Run: `ls build/index.js build/client.js build/errors.js build/logger.js build/types.js` -- all files must exist.
Run: `node -e "import('./build/tools/ping.js').then(m => console.log(Object.keys(m)))"` -- should show registerPingTool.
Run: `echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18","capabilities":{},"clientInfo":{"name":"test","version":"1.0.0"}}}' | LIGHTDASH_API_KEY=test LIGHTDASH_API_URL=https://example.com timeout 5 node build/index.js 2>/dev/null` -- should output valid JSON-RPC initialize response (proves stdout purity and server bootstrap work). The response should contain "lightdash" as server name.
  </verify>
  <done>lightdash_ping tool registered with lightdash_ prefix and readOnlyHint annotation. Full project compiles to build/ with all 6 JS files present. Server responds to JSON-RPC initialize with valid response containing server name "lightdash". No non-JSON-RPC output on stdout.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds (BLDP-01)
2. Server exits with FATAL stderr message when env vars missing (INFRA-02)
3. JSON-RPC initialize handshake works via stdio (INFRA-01)
4. build/ contains all expected JS files
5. lightdash_ping tool exports correctly and uses lightdash_ prefix (INFRA-10) with readOnlyHint (INFRA-11)
6. Tool handler wrapped with wrapToolHandler (INFRA-07, INFRA-09)
7. Tool applies field filtering on response (INFRA-06)
</verification>

<success_criteria>
All 12 Phase 1 requirements verified:
- INFRA-01: Zero non-JSON-RPC stdout output (console.log overridden)
- INFRA-02: Fail-fast on missing env vars with clear stderr message
- INFRA-03: Auto-append /api/v1 (in client.ts, validated by ping tool)
- INFRA-04: ApiKey auth header (in client.ts)
- INFRA-05: Envelope unwrapping (in client.ts handleResponse)
- INFRA-06: Field filtering (in ping tool, org -> 3 fields)
- INFRA-07: isError: true error format (via wrapToolHandler)
- INFRA-08: Timeouts (30s default in client.ts)
- INFRA-09: Error sanitization (no keys, URLs, stack traces)
- INFRA-10: lightdash_ tool prefix
- INFRA-11: readOnlyHint: true annotation
- BLDP-01: TypeScript compiles to build/
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-stdio-infrastructure/01-03-SUMMARY.md`
</output>
