---
phase: 01-foundation-stdio-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/client.ts
autonomous: true

must_haves:
  truths:
    - "Client auto-appends /api/v1 to base URL that does not already end with it"
    - "Client does NOT double-append /api/v1 if base URL already contains it"
    - "Client includes Authorization: ApiKey header on every request"
    - "Client unwraps { status, results } envelope and returns only the results value"
    - "Client applies 30s default timeout and allows per-request override"
    - "Client throws LightdashApiError on non-2xx responses with safe extracted message"
  artifacts:
    - path: "src/client.ts"
      provides: "LightdashClient class with get() and post() methods"
      exports: ["LightdashClient"]
      min_lines: 50
  key_links:
    - from: "src/client.ts"
      to: "src/errors.ts"
      via: "imports LightdashApiError for HTTP error handling"
      pattern: "import.*LightdashApiError.*errors"
    - from: "src/client.ts"
      to: "built-in fetch"
      via: "uses global fetch with AbortSignal.timeout for all HTTP calls"
      pattern: "AbortSignal\\.timeout"
---

<objective>
Create the LightdashClient class -- the centralized HTTP client that every tool uses to call the Lightdash API.

Purpose: This is the single point of contact with the Lightdash API. It handles auth header injection (INFRA-04), base URL normalization with /api/v1 auto-append (INFRA-03), response envelope unwrapping (INFRA-05), timeouts (INFRA-08), and HTTP error detection. No tool should ever construct fetch calls directly.

Output: src/client.ts exporting LightdashClient class with get() and post() methods.
</objective>

<execution_context>
@/Users/mikhailgasanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mikhailgasanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-stdio-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-stdio-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LightdashClient with auth, URL normalization, envelope unwrapping, and timeouts</name>
  <files>src/client.ts</files>
  <action>
Create `src/client.ts` exporting the `LightdashClient` class.

**Constructor** takes config object `{ baseUrl: string; apiKey: string; defaultTimeout?: number }`:
1. Strip trailing slashes from baseUrl
2. Auto-append `/api/v1` if the URL does not already end with `/api/v1` (INFRA-03). Check with `url.endsWith("/api/v1")` AFTER stripping trailing slashes.
3. Store headers: `{ "Authorization": "ApiKey {apiKey}", "Content-Type": "application/json" }` (INFRA-04)
4. Store defaultTimeout (default 30_000ms per INFRA-08)

**`get<T>(path: string, timeoutMs?: number): Promise<T>`**:
1. Construct full URL: `{baseUrl}{path}` (path should start with `/`)
2. Call `fetch` with method GET, stored headers, and `signal: AbortSignal.timeout(timeoutMs ?? this.defaultTimeout)`
3. Pass response to `handleResponse<T>`

**`post<T>(path: string, body?: unknown, timeoutMs?: number): Promise<T>`**:
1. Same as get but with method POST and `body: body ? JSON.stringify(body) : undefined`
2. Use `timeoutMs ?? this.defaultTimeout` for signal

**`private async handleResponse<T>(response: Response): Promise<T>`**:
1. If `!response.ok`: read body as text (with `.catch(() => "")` for safety), throw `new LightdashApiError(response.status, text)` (INFRA-07 via errors.ts)
2. Parse JSON as `{ status: string; results: T }`
3. Return `json.results` -- this is the envelope unwrap (INFRA-05)

Import `LightdashApiError` from `./errors.js` (note .js extension for ESM).
Import `log` from `./logger.js` for debug logging of requests.

Add a `debug` log line in get/post showing the method and path (NOT the full URL -- avoid logging the base URL which might be considered sensitive). Example: `log.debug("GET /org/projects")`.

IMPORTANT: Do NOT log the API key or the full base URL. Only log the relative path.
  </action>
  <verify>
Run: `cd "/Users/mikhailgasanov/Documents/Lightdash MCP" && npx tsc --noEmit` -- zero errors.
Run: `npx tsc && node -e "
import { LightdashClient } from './build/client.js';
const c = new LightdashClient({ baseUrl: 'https://example.com', apiKey: 'test' });
console.log('OK: client created');
"` -- should print "OK: client created" without errors.
Run: `npx tsc && node -e "
import { LightdashClient } from './build/client.js';
// Verify /api/v1 auto-append by checking internal state
const c1 = new LightdashClient({ baseUrl: 'https://example.com', apiKey: 'test' });
const c2 = new LightdashClient({ baseUrl: 'https://example.com/api/v1', apiKey: 'test' });
const c3 = new LightdashClient({ baseUrl: 'https://example.com/', apiKey: 'test' });
console.log('All clients created without error');
"` -- should succeed.
  </verify>
  <done>LightdashClient class compiles, can be instantiated with various URL formats, auto-appends /api/v1, and exports correctly. All imports use .js extensions.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` produces zero errors with client.ts included
2. LightdashClient can be instantiated without runtime errors
3. Source code review confirms: auth header set, /api/v1 logic correct, envelope unwrap in handleResponse, AbortSignal.timeout used
</verification>

<success_criteria>
- LightdashClient class exists with get() and post() methods
- Auto-appends /api/v1 to base URL (INFRA-03)
- Authorization: ApiKey header on all requests (INFRA-04)
- Unwraps { results } envelope (INFRA-05)
- AbortSignal.timeout with 30s default (INFRA-08)
- Throws LightdashApiError on HTTP errors
- No sensitive data in debug logs
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-stdio-infrastructure/01-02-SUMMARY.md`
</output>
